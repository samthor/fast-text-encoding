{
  "version": 3,
  "sources": ["src/buffer.js", "src/lowlevel.js", "src/shared.js", "src/support.js", "src/o-encoder.js", "src/xhr.js", "src/o-decoder.js", "src/polyfill.js"],
  "sourcesContent": ["\r\n/**\r\n * @param {Uint8Array} bytes\r\n * @param {string} encoding\r\n * @return {string}\r\n */\r\nexport function decodeBuffer(bytes, encoding, fatal) {\r\n  /** @type {Buffer} */\r\n  var b;\r\n  if (bytes instanceof Buffer) {\r\n    // @ts-ignore\r\n    b = bytes;\r\n  } else {\r\n    try {\r\n      b = Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength);\r\n    } catch(err) {\r\n      if (!fatal) {\r\n        return '';\r\n      } else {\r\n        throw err;\r\n      }\r\n    }\r\n   }\r\n  return b.toString(/** @type {BufferEncoding} */(encoding));\r\n}\r\n\r\n\r\n/**\r\n * @param {string} string\r\n * @return {Uint8Array}\r\n */\r\nexport var encodeBuffer = (string) => Buffer.from(string);\r\n", "\r\n/** @type {(bytes: Uint8Array, encoding: string, fatal: boolean) => string} */\r\nexport function decodeFallback(bytes, encoding, fatal) {\r\n  var inputIndex = 0;\r\n\r\n  // Create a working buffer for UTF-16 code points, but don't generate one\r\n  // which is too large for small input sizes. UTF-8 to UCS-16 conversion is\r\n  // going to be at most 1:1, if all code points are ASCII. The other extreme\r\n  // is 4-byte UTF-8, which results in two UCS-16 points, but this is still 50%\r\n  // fewer entries in the output.\r\n  var pendingSize = Math.min(256 * 256, bytes.length + 1);\r\n  var pending = new Uint16Array(pendingSize);\r\n  var chunks = [];\r\n  var pendingIndex = 0;\r\n\r\n  for (; ;) {\r\n    var more = inputIndex < bytes.length;\r\n\r\n    // If there's no more data or there'd be no room for two UTF-16 values,\r\n    // create a chunk. This isn't done at the end by simply slicing the data\r\n    // into equal sized chunks as we might hit a surrogate pair.\r\n    if (!more || (pendingIndex >= pendingSize - 1)) {\r\n      // nb. .apply and friends are *really slow*. Low-hanging fruit is to\r\n      // expand this to literally pass pending[0], pending[1], ... etc, but\r\n      // the output code expands pretty fast in this case.\r\n      // These extra vars get compiled out: they're just to make TS happy.\r\n      // Turns out you can pass an ArrayLike to .apply().\r\n      var subarray = pending.subarray(0, pendingIndex);\r\n      var arraylike = /** @type {number[]} */ (/** @type {unknown} */ (subarray));\r\n      chunks.push(String.fromCharCode.apply(null, arraylike));\r\n\r\n      if (!more) {\r\n        return chunks.join('');\r\n      }\r\n\r\n      // Move the buffer forward and create another chunk.\r\n      bytes = bytes.subarray(inputIndex);\r\n      inputIndex = 0;\r\n      pendingIndex = 0;\r\n    }\r\n\r\n    // The native TextDecoder will generate \"REPLACEMENT CHARACTER\" where the\r\n    // input data is invalid. Here, we blindly parse the data even if it's\r\n    // wrong: e.g., if a 3-byte sequence doesn't have two valid continuations.\r\n\r\n    var byte1 = bytes[inputIndex++];\r\n    if ((byte1 & 0x80) === 0) {  // 1-byte or null\r\n      pending[pendingIndex++] = byte1;\r\n    } else if ((byte1 & 0xe0) === 0xc0) {  // 2-byte\r\n      var byte2 = bytes[inputIndex++] & 0x3f;\r\n      pending[pendingIndex++] = ((byte1 & 0x1f) << 6) | byte2;\r\n    } else if ((byte1 & 0xf0) === 0xe0) {  // 3-byte\r\n      var byte2 = bytes[inputIndex++] & 0x3f;\r\n      var byte3 = bytes[inputIndex++] & 0x3f;\r\n      pending[pendingIndex++] = ((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3;\r\n    } else if ((byte1 & 0xf8) === 0xf0) {  // 4-byte\r\n      var byte2 = bytes[inputIndex++] & 0x3f;\r\n      var byte3 = bytes[inputIndex++] & 0x3f;\r\n      var byte4 = bytes[inputIndex++] & 0x3f;\r\n\r\n      // this can be > 0xffff, so possibly generate surrogates\r\n      var codepoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\r\n      if (codepoint > 0xffff) {\r\n        // codepoint &= ~0x10000;\r\n        codepoint -= 0x10000;\r\n        pending[pendingIndex++] = (codepoint >>> 10) & 0x3ff | 0xd800;\r\n        codepoint = 0xdc00 | codepoint & 0x3ff;\r\n      }\r\n      pending[pendingIndex++] = codepoint;\r\n    } else if (fatal) {\r\n      // invalid initial byte\r\n      throw new Error('invalid input');\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @param {string} string\r\n * @return {Uint8Array}\r\n */\r\nexport function encodeFallback(string) {\r\n  var pos = 0;\r\n  var len = string.length;\r\n\r\n  var at = 0;  // output position\r\n  var tlen = Math.max(32, len + (len >>> 1) + 7);  // 1.5x size\r\n  var target = new Uint8Array((tlen >>> 3) << 3);  // ... but at 8 byte offset\r\n\r\n  while (pos < len) {\r\n    var value = string.charCodeAt(pos++);\r\n    if (value >= 0xd800 && value <= 0xdbff) {\r\n      // high surrogate\r\n      if (pos < len) {\r\n        var extra = string.charCodeAt(pos);\r\n        if ((extra & 0xfc00) === 0xdc00) {\r\n          ++pos;\r\n          value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\r\n        }\r\n      }\r\n      if (value >= 0xd800 && value <= 0xdbff) {\r\n        continue;  // drop lone surrogate\r\n      }\r\n    }\r\n\r\n    // expand the buffer if we couldn't write 4 bytes\r\n    if (at + 4 > target.length) {\r\n      tlen += 8;  // minimum extra\r\n      tlen *= (1.0 + (pos / string.length) * 2);  // take 2x the remaining\r\n      tlen = (tlen >>> 3) << 3;  // 8 byte offset\r\n\r\n      var update = new Uint8Array(tlen);\r\n      update.set(target);\r\n      target = update;\r\n    }\r\n\r\n    if ((value & 0xffffff80) === 0) {  // 1-byte\r\n      target[at++] = value;  // ASCII\r\n      continue;\r\n    } else if ((value & 0xfffff800) === 0) {  // 2-byte\r\n      target[at++] = ((value >>> 6) & 0x1f) | 0xc0;\r\n    } else if ((value & 0xffff0000) === 0) {  // 3-byte\r\n      target[at++] = ((value >>> 12) & 0x0f) | 0xe0;\r\n      target[at++] = ((value >>> 6) & 0x3f) | 0x80;\r\n    } else if ((value & 0xffe00000) === 0) {  // 4-byte\r\n      target[at++] = ((value >>> 18) & 0x07) | 0xf0;\r\n      target[at++] = ((value >>> 12) & 0x3f) | 0x80;\r\n      target[at++] = ((value >>> 6) & 0x3f) | 0x80;\r\n    } else {\r\n      continue;  // out of range\r\n    }\r\n\r\n    target[at++] = (value & 0x3f) | 0x80;\r\n  }\r\n\r\n  // Use subarray if slice isn't supported (IE11). This will use more memory\r\n  // because the original array still exists.\r\n  return target.slice ? target.slice(0, at) : target.subarray(0, at);\r\n}\r\n", "\r\nexport var failedToString = 'Failed to ';\r\n\r\n/**\r\n * @param {boolean|undefined} check \r\n * @param {string} operation \r\n * @param {string} fieldName \r\n */\r\nexport var maybeThrowFailedToOption = (check, operation, fieldName) => {\r\n  if (check) {\r\n    throw new Error(`${failedToString}${operation}: the '${fieldName}' option is unsupported.`);\r\n  }\r\n};", "\r\nexport var hasBufferFrom = (typeof Buffer === 'function' && Buffer.from);", "import { encodeBuffer } from './buffer.js';\r\nimport { encodeFallback } from './lowlevel.js';\r\nimport { maybeThrowFailedToOption } from './shared.js';\r\nimport { hasBufferFrom } from './support.js';\r\n\r\nexport var encodeImpl = hasBufferFrom ? encodeBuffer : encodeFallback;\r\n\r\n/**\r\n * @constructor\r\n */\r\nexport function FastTextEncoder() {\r\n  // This does not accept an encoding, and always uses UTF-8:\r\n  //   https://www.w3.org/TR/encoding/#dom-textencoder\r\n  this.encoding = 'utf-8';\r\n}\r\n\r\n/**\r\n * @param {string} string\r\n * @param {{stream: boolean}=} options\r\n * @return {Uint8Array}\r\n */\r\nFastTextEncoder.prototype.encode = function (string, options) {\r\n  maybeThrowFailedToOption(options && options.stream, 'encode', 'stream');\r\n  return encodeImpl(string);\r\n};\r\n", "\r\n/**\r\n * This is a horrible hack which works in some old browsers. We can tell them to decode bytes via\r\n * sync XHR.\r\n *\r\n * Throws if fails. Should be wrapped in something to check that.\r\n *\r\n * @param {Uint8Array} bytes\r\n * @return {string}\r\n */\r\nexport function decodeSyncXHR(bytes) {\r\n  var u;\r\n\r\n  // This hack will fail in non-Edgium Edge because sync XHRs are disabled (and\r\n  // possibly in other places), so ensure there's a fallback call.\r\n  try {\r\n    var b = new Blob([bytes], { type: 'text/plain;charset=UTF-8' });\r\n    u = URL.createObjectURL(b);\r\n\r\n    var x = new XMLHttpRequest();\r\n    x.open('GET', u, false);\r\n    x.send();\r\n    return x.responseText;\r\n  } finally {\r\n    if (u) {\r\n      URL.revokeObjectURL(u);\r\n    }\r\n  }\r\n}", "import { decodeBuffer } from './buffer.js';\r\nimport { decodeFallback } from './lowlevel.js';\r\nimport { failedToString, maybeThrowFailedToOption } from './shared.js';\r\nimport { hasBufferFrom } from './support.js';\r\nimport { decodeSyncXHR } from './xhr.js';\r\n\r\nvar trySyncXHR = !hasBufferFrom && (typeof Blob === 'function' && typeof URL === 'function' && typeof URL.createObjectURL === 'function');\r\nvar validUtfLabels = ['utf-8', 'utf8', 'unicode-1-1-utf-8'];\r\n\r\n/** @type {(bytes: Uint8Array, encoding: string, fatal: boolean) => string} */\r\nvar decodeImpl = decodeFallback;\r\nif (hasBufferFrom) {\r\n  decodeImpl = decodeBuffer;\r\n} else if (trySyncXHR) {\r\n  decodeImpl = (string, encoding, fatal) => {\r\n    try {\r\n      return decodeSyncXHR(string);\r\n    } catch (e) {\r\n      return decodeFallback(string, encoding, fatal);\r\n    }\r\n  };\r\n}\r\n\r\n\r\nvar ctorString = `construct 'TextDecoder'`;\r\nvar errorPrefix = `${failedToString} ${ctorString}: the `;\r\n\r\n\r\n/**\r\n * @constructor\r\n * @param {string=} utfLabel\r\n * @param {{fatal: boolean}=} options\r\n */\r\nexport function FastTextDecoder(utfLabel, options) {\r\n  utfLabel = utfLabel || 'utf-8';\r\n\r\n  /** @type {boolean} */\r\n  var ok;\r\n  if (hasBufferFrom) {\r\n    ok = Buffer.isEncoding(utfLabel);\r\n  } else {\r\n    ok = validUtfLabels.indexOf(utfLabel.toLowerCase()) !== -1;\r\n  }\r\n  if (!ok) {\r\n    throw new RangeError(`${errorPrefix} encoding label provided ('${utfLabel}') is invalid.`);\r\n  }\r\n\r\n  this.encoding = utfLabel;\r\n  this.fatal = options && options.fatal\r\n    ? true\r\n    : false;\r\n  this.ignoreBOM = false;\r\n}\r\n\r\n/**\r\n * @param {(ArrayBuffer|ArrayBufferView)} buffer\r\n * @param {{stream: boolean, fatal: boolean}=} options\r\n * @return {string}\r\n */\r\nFastTextDecoder.prototype.decode = function (buffer, options) {\r\n  maybeThrowFailedToOption(options && options.stream, 'decode', 'stream');\r\n\r\n  var bytes;\r\n\r\n  if (buffer instanceof Uint8Array) {\r\n    // Accept Uint8Array instances as-is. This is also a Node buffer.\r\n    bytes = buffer;\r\n  } else if (buffer['buffer'] instanceof ArrayBuffer) {\r\n    // Look for ArrayBufferView, which isn't a real type, but basically\r\n    // represents all the valid TypedArray types plus DataView. They all have\r\n    // \".buffer\" as an instance of ArrayBuffer.\r\n    bytes = new Uint8Array(/** @type {ArrayBufferView} */(buffer).buffer);\r\n  } else {\r\n    // The only other valid argument here is that \"buffer\" is an ArrayBuffer.\r\n    // We also try to convert anything else passed to a Uint8Array, as this\r\n    // catches anything that's array-like. Native code would throw here.\r\n    bytes = new Uint8Array(/** @type {any} */(buffer));\r\n  }\r\n\r\n  return decodeImpl(bytes, this.encoding, this.fatal);\r\n};\r\n", "\r\nimport { FastTextEncoder } from './o-encoder.js';\r\nimport { FastTextDecoder } from './o-decoder.js';\r\n\r\n// /** @type {object} */\r\n// const scope = typeof window !== 'undefined' ? window : (typeof global !== 'undefined' ? global : this);\r\n\r\nscope['TextEncoder'] = scope['TextEncoder'] || FastTextEncoder;\r\nscope['TextDecoder'] = scope['TextDecoder'] || FastTextDecoder;\r\n\r\n// export {};\r\n"],
  "mappings": "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",
  "names": ["decodeBuffer", "bytes", "encoding", "fatal", "b", "err", "encodeBuffer", "string", "decodeFallback", "bytes", "encoding", "fatal", "inputIndex", "pendingSize", "pending", "chunks", "pendingIndex", "more", "subarray", "arraylike", "byte1", "byte2", "byte3", "byte4", "codepoint", "encodeFallback", "string", "pos", "len", "at", "tlen", "target", "value", "extra", "update", "failedToString", "maybeThrowFailedToOption", "check", "operation", "fieldName", "hasBufferFrom", "encodeImpl", "hasBufferFrom", "encodeBuffer", "encodeFallback", "FastTextEncoder", "string", "options", "maybeThrowFailedToOption", "decodeSyncXHR", "bytes", "u", "b", "x", "trySyncXHR", "hasBufferFrom", "validUtfLabels", "decodeImpl", "decodeFallback", "decodeBuffer", "string", "encoding", "fatal", "decodeSyncXHR", "ctorString", "errorPrefix", "failedToString", "FastTextDecoder", "utfLabel", "options", "ok", "buffer", "maybeThrowFailedToOption", "bytes", "FastTextEncoder", "FastTextDecoder"]
}
